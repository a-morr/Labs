import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import inv, norm

class KalmanFilter(object):
    def __init__(self,F,Q,H,R,u):
        """
        Initialize the dynamical system models.
        
        Parameters
        ----------
        F : ndarray of shape (n,n)
            The state transition model.
        Q : ndarray of shape (n,n)
            The covariance matrix for the state noise.
        H : ndarray of shape (m,n)
            The observation model.
        R : ndarray of shape (m,m)
            The covariance matric for observation noise.
        u : ndarray of shape (n,)
            The control vector.
        """
        self.F = F
        self.Q = Q
        self.H = H
        self.R = R
        self.u = u
    
    def evolve(self,x0,N):
        """
        Compute the first N states and observations generated by the Kalman system.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state.
        N : integer
            The number of time steps to evolve.

        Returns
        -------
        states : ndarray of shape (n,N)
            The i-th column gives the i-th state.
        obs : ndarray of shape (m,N)
            The i-th column gives the i-th observation.
        """
        # initialize variables
        m,n = self.H.shape
        states = np.zeros((n,N))
        obs = np.zeros((m,N))

        # pre-compute the noises (each row gives a draw)
        w = np.random.multivariate_normal(np.zeros(n), self.Q, size=N-1)
        v = np.random.multivariate_normal(np.zeros(m), self.R, size=N)

        # store the initial state
        states[:,0] = x0

        # calculate and store the initial observation
        obs[:,0] = np.dot(self.H,x0) + v[0,:]

        for i in xrange(N-1):
            # calculate and store next state
            states[:,i+1] = np.dot(self.F,states[:,i]) + self.u + w[i,:]

            # calculate and store next observation
            obs[:,i+1] = np.dot(self.H,states[:,i+1]) + v[i+1,:]

        return states, obs 

    def estimate(self,x0,P0,z, return_norms = False):
        """
        Compute the state estimates using the kalman filter.

        Parameters
        ----------
        x0 : ndarray of shape (n,)
            The initial state estimate.
        P0 : ndarray of shape (n,n)
            The initial error covariance matrix.
        z : ndarray of shape(m,N)
            Sequence of N observations (each column is an observation).

        Returns
        -------
        out : ndarray of shape (n,N)
            Sequence of state estimates (each column is an estimate).
        norms: list of floats of length N
            Gives the norm of the error matrix for each estimate.
        """
        n = self.F.shape[0]
        N = z.shape[1]
        out = np.zeros((n,N+1))
        out[:,0] = x0
        norms = []
        P = P0.copy()
        norms.append(norm(P))
        I = np.eye(n)
        for i in xrange(1,N+1):
            # predict step
            xprime = np.dot(self.F,out[:,i-1]) + self.u
            Pprime = np.dot(np.dot(self.F,P),self.F.T)+self.Q
            # update step
            y = z[:,i-1] - np.dot(self.H,xprime)
            S = np.dot(np.dot(self.H,Pprime), self.H.T) + self.R
            K = np.dot(np.dot(Pprime,self.H.T),inv(S))
            out[:,i] = xprime + np.dot(K,y)
            P = np.dot(I-np.dot(K,self.H), Pprime)
            norms.append(norm(P))
        if return_norms:
            return out[:,1:], norms
        else:
            return out[:,1:]
            
    
    def predict(self,x,k):
        """
        Predict the next k states in the absence of observations.

        Parameters
        ----------
        x : ndarray of shape (n,)
            The current state estimate.
        k : integer
            The number of states to predict.

        Returns
        -------
        out : ndarray of shape (n,k)
            The next k predicted states.
        """
        n = self.F.shape[0]
        out = np.zeros((n,k+1))
        out[:,0] = x
        for i in xrange(k):
            out[:,i+1] = np.dot(self.F,out[:,i]) + self.u
        return out[:,1:]
    
    def rewind(self,x,k):
        """
        Predict the states from time 0 through k-1 in the absence of observations.
    
        Parameters
        ----------
        x : ndarray of shape (n,)
            The state estimate at time k.
        k : integer
            The current time step.
    
        Returns
        -------
        out : ndarray of shape (n,k)
            The predicted states from time 0 up through k-1 (in that order).
        """
        n = self.F.shape[0]
        Finv = inv(self.F)
        out = np.zeros((n,k+1))
        out[:,-1] = x
        for i in xrange(k-1,-1,-1):
            out[:,i] = np.dot(Finv,out[:,i+1]-self.u)
        return out[:,:-1]

# initialize the projectile system parameters and kalman filter
u = np.array([0,0,0,-.98])
H = np.array([[1,0,0,0],[0,1.,0,0]])
Q = 0.1*np.eye(4)
R = 5000*np.eye(2)
F = np.array([[1,0,.1,0],[0,1,0,.1],[0,0,1,0],[0,0,0,1]])
x0 = np.array([0,0,300.,600])
kal = KalmanFilter(F,Q,H,R,u)

# simulate state sequence and observations
s,o = kal.evolve(x0,1250)

# estimate states given observations 200 through 800
ave_vel = np.diff(o[:,200:210], axis=1).mean(axis=1)/.1
x = np.zeros(4)
x[:2] = o[:,200]
x[2:] = ave_vel
P = 10**6*Q
estimates = kal.estimate(x,P,o[:,201:801])

# predict states until impact given state estimate at time 800
predicted = kal.predict(estimates[:,-1],450)

# predict states from origin given state estimate at time 250
rewound = kal.rewind(estimates[:,49],300)

# plot all the results
plt.plot(s[0,:], s[1,:])
plt.plot(o[0,201:801], o[1,201:801], 'r.')
plt.plot(estimates[0,:],estimates[1,:], 'g')
plt.plot(predicted[0,:],predicted[1,:], 'y')
plt.plot(rewound[0,:],rewound[1,:], 'c')
plt.ylim(0)
plt.show()
